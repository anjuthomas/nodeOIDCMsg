var JsonWebTokenError = require('./lib/JsonWebTokenError');
var NotBeforeError    = require('./lib/NotBeforeError');
var TokenExpiredError = require('./lib/TokenExpiredError');
var decode            = require('./decode');
var timespan          = require('./lib/timespan');
var jws               = require('jws');
var xtend             = require('xtend');
var message           = require('message');

module.exports = function (jwtSig, secretOrPublicKey, tokenProfile, otherOptions, callback) {
  message.verify(jwtSig, secretOrPublicKey, otherOptions, callback);
  var decoded = jws.decode(jwtSig, secretOrPublicKey, tokenProfile, otherOptions, callback);
  if (!decoded) { return callback(new JsonWebTokenError('invalid token')); }

  var header = decoded.header;
  var done;
  
  if (callback) {
    done = callback;
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }
if (otherOptions && otherOptions.algorithms){
  if (!~otherOptions.algorithms.indexOf(header.alg)) {
    return done(new JsonWebTokenError('invalid algorithm'));
  }

  if (otherOptions.algorithms.indexOf('none') != -1 && tokenProfile.getNoneAlgorithm() == false) {
    return done(new JsonWebTokenError('Cannot use none algorithm unless explicitly set'));
  }
}

  var valid;
  
  try {
    valid = jws.verify(jwtSig, header.alg, secretOrPublicKey);
  } catch (e) {
    return done(e);
  }
  
  if (!valid)
    return done(new JsonWebTokenError('invalid signature'));

  var payload = decoded.payload;

  //try parse the payload
  if(typeof payload === 'string') {
    try {
      var obj = JSON.parse(payload);
      if(typeof obj === 'object') {
        payload = obj;
      }
    } catch (e) { }
  }

  var payload = message.decode(payload, tokenProfile,callback);


  //return header if `complete` option is enabled.  header includes claims
  //such as `kid` and `alg` used to select the key within a JWKS needed to
  //verify the signature
  if (otherOptions && otherOptions.complete === true) {
    return {
      header: decoded.header,
      payload: payload,
      signature: decoded.signature
    };
  }
  
  return payload;
};
