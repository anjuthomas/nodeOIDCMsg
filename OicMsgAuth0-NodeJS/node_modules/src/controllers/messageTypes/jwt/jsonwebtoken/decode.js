var JsonWebTokenError = require('./lib/JsonWebTokenError');
var NotBeforeError    = require('./lib/NotBeforeError');
var TokenExpiredError = require('./lib/TokenExpiredError');
var decode            = require('./decode');
var timespan          = require('./lib/timespan');
var jws               = require('../lib/jws');
var xtend             = require('xtend');
var jwtVerifier       = require('./verify')

var jwtDecoder = JWTDecoder.prototype;

function JWTDecoder(){
};
/* Check jwt signature and other option values */ 
jwtDecoder.decode = function (jwtSig, secretOrPublicKey, tokenProfile, otherOptions, callback) {
  // Verifications of other options and jwt string signature
  jwtVerifier.verifyOptions(jwtSig, secretOrPublicKey, otherOptions, callback);

  // Decodes type jwt and returns header, payload & signature
  var decoded = jws.decode(jwtSig, secretOrPublicKey, tokenProfile, otherOptions, callback);
  if (!decoded) { return callback(new JsonWebTokenError('invalid token')); }
  var header = decoded.header;

  var done = this.initCallback(callback);

  this.verifyHeaderAlgorithm(otherOptions, header)

  this.validateJws(jwtSig, header.alg, secretOrPublicKey, done)

  var payload = decoded.payload;
  this.parsePayload(payload);

  // verify payload values matches expected values
  var payload =  jwtVerifier.verifyPayload(payload, tokenProfile,otherOptions, callback);

  //return header if `complete` option is enabled.  header includes claims
  //such as `kid` and `alg` used to select the key within a JWKS needed to
  //verify the signature
  if (otherOptions && otherOptions.complete === true) {
    return {
      header: decoded.header,
      payload: payload,
      signature: decoded.signature
    };
  }
  
  return payload;
};

/* Initialize callback */
jwtDecoder.initCallback = function(callback){
  var done;
  
  if (callback) {
    done = callback;
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }
  return done;
}

/* Algorithms check based on decoded header */
jwtDecoder.verifyHeaderAlgorithm = function(otherOptions, header){
  if (otherOptions && otherOptions.algorithms){
    if (!~otherOptions.algorithms.indexOf(header.alg)) {
      return done(new JsonWebTokenError('invalid algorithm'));
    }
  
    if (otherOptions.algorithms.indexOf('none') != -1 && tokenProfile.getNoneAlgorithm() == false) {
      return done(new JsonWebTokenError('Cannot use none algorithm unless explicitly set'));
    }
  }
}

jwtDecoder.validateJws = function(jwtSig, algorithm, secretOrPublicKey, done){
  var valid;
  
  try {
    valid = jws.verify(jwtSig, algorithm, secretOrPublicKey);
  } catch (e) {
    return done(e);
  }
  
  if (!valid)
    return done(new JsonWebTokenError('invalid signature'));
}

/* Parse payload */
jwtDecoder.parsePayload = function(payload){
  if(typeof payload === 'string') {
    try {
      var obj = JSON.parse(payload);
      if(typeof obj === 'object') {
        payload = obj;
      }
    } catch (e) { }
  }
}

module.exports = jwtDecoder;