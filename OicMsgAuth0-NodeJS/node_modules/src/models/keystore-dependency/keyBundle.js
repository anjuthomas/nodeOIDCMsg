
var jwkToPem = require('jwk-to-pem');
var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
var async = require('asyncawait/async');
var await = require('asyncawait/await');


var keyBundle = KeyBundle.prototype;

/*
var K2C = {
    "RSA": RSAKey,
    "EC": ECKey,
    "oct": SYMKey,
}

var MAP = {'dec': 'enc', 'enc': 'enc', 'ver': 'sig', 'sig': 'sig'}*/

function KeyBundle(keys=[], source="", fileformat="jwk", cache_time=300, verify_ssl=true, keyType="RSA", encEnc="A128CBC-HS256", keytype="RSA", keyusage="None"){
    /*
    Contains a set of keys that have a common origin.
    The sources can be serveral:
    - A dictionary provided at the initialization, see keys below.
    - A list of dictionaries provided at initialization
    - A file containing one of: JWKS, DER encoded key
    - A URL pointing to a webpages from which an JWKS can be downloaded
             
    :param keys: A dictionary or a list of dictionaries
        with the keys ["kty", "key", "alg", "use", "kid"]
    :param source: Where the key set can be fetch from
    :param verify_ssl: Verify the SSL cert used by the server
    :param fileformat: For a local file either "jwk" or "der"
    :param keytype: Iff local file and 'der' format what kind of key it is.
        presently only 'rsa' is supported.
    :param keyusage: What the key loaded from file should be used for.
        Only applicable for DER files
    */
    
    this.keys = keys;
    this.remote = false;
    this.verify_ssl = verify_ssl;
    this.cache_time = cache_time;
    this.time_out = 0;
    this.etag = "";
    this.source = source;
    this.fileformat = fileformat.toLowerCase();
    this.keytype = keytype;
    this.keyusage = keyusage;
    this.imp_jwks = null;
    this.last_updated = 0;
    this.formattedKeysList = [];
};

keyBundle.getKty = function(typ=""){
    var keysList = []
    for (var index in this.imp_jwks.keys){
        var key = this.imp_jwks.keys[index]
        if (key.kty == typ)
            keysList.push(jwkToPem(key));
    }
    return keysList;
};

keyBundle.getKeyList = function(keys){
    var keysList = []
    var impJwks = this.getJwks();
    if (keys.length == 0 && impJwks){
        keys = impJwks.keys;
    }
    for (var index in keys){
        var key = jwkToPem(keys[index])
        keysList.push(key);
    }
    this.formattedKeysList = keysList;
    return keysList;
};

keyBundle.getKeys = function(){
    if (this.formattedKeysList.length != 0){
        return this.formattedKeysList;
    }
    else if (this.source != ""){
        var HttpClient = function() {
            this.get = function(aUrl, aCallback) {
                var anHttpRequest = new XMLHttpRequest();
                anHttpRequest.onreadystatechange = function() { 
                    if (anHttpRequest.readyState == 4 && anHttpRequest.status == 200)
                        aCallback(anHttpRequest.responseText);
                }
        
                anHttpRequest.open( "GET", aUrl, true );            
                anHttpRequest.send( null );
            }
          }
        
          var client = new HttpClient();
          client.get(this.source, function(response) {
            // do something with response
            var keys = JSON.parse(response).keys;
            return keyBundle.getKeyList(keys);
          });
    }else{
        return this.getKeyList(this.keys);
    }
};

keyBundle.getKeyWithKid = function(kid){
    //throw new Error("Unsupported Operation Exception");    

    for (var index in this.imp_jwks.keys){
        var key = this.imp_jwks.keys[index]
        if (key.kid == kid)
            return key;
    }
};

keyBundle.getJwks= function(private=false){
    return this.imp_jwks;   
};

keyBundle.append = function(key){
    throw new Error("Unsupported Operation Exception");    
};

keyBundle.remove = function(key){
    var i = this.formattedKeysList.indexOf(key);
    if(i != -1) {
        this.formattedKeysList.splice(i, 1);
    }
};

keyBundle.doKeys = function(keys){
    throw new Error("Unsupported Operation Exception");         
};

keyBundle.doLocalJwk = function(filename){
    throw new Error("Unsupported Operation Exception");    
};

keyBundle.doLocalDer = function(filename, keytype, keyUsage){
    throw new Error("Unsupported Operation Exception");
};

keyBundle.do_remote = function(){
    throw new Error("Unsupported Operation Exception");    
};

keyBundle.parseRemoteResponse = function(response){
    throw new Error("Unsupported Operation Exception");    
};

keyBundle.upToDate = function(){
    throw new Error("Unsupported Operation Exception");    
}

keyBundle.update = function(token){
    throw new Error("Unsupported Operation Exception");    
};


keyBundle.availableKeys = function(){
    throw new Error("Unsupported Operation Exception");    
}

keyBundle.removeKey = function(type, val=None){
    throw new Error("Unsupported Operation Exception");    
};

keyBundle.toString = function(type, val=None){
    throw new Error("Unsupported Operation Exception");    
};



keyBundle.length= function(){
    throw new Error("Unsupported Operation Exception");    
};

keyBundle.kids = function(){
    throw new Error("Unsupported Operation Exception");    
};

keyBundle.removeOutdated = function(after, when=0){
    throw new Error("Unsupported Operation Exception");    
};

keyBundle.keybundleFromLocalFile= function(fileName, typ, usage){
    throw new Error("Unsupported Operation Exception");    
};

module.exports = KeyBundle;

