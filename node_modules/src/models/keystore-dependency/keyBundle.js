
var jwkToPem = require('jwk-to-pem');
var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest;
var async = require('asyncawait/async');
var await = require('asyncawait/await');
var fs = require('fs');
var path = require('path');   
var forge = require('node-forge');

var keyBundle = KeyBundle.prototype;

/*
var K2C = {
    "RSA": RSAKey,
    "EC": ECKey,
    "oct": SYMKey,
}

var MAP = {'dec': 'enc', 'enc': 'enc', 'ver': 'sig', 'sig': 'sig'}*/

function KeyBundle(keys=[], source="", fileformat="jwk", keyusage="None", cache_time=300, verify_ssl=true, keyType="RSA", encEnc="A128CBC-HS256", keytype="RSA"){
    /*
    Contains a set of keys that have a common origin.
    The sources can be serveral:
    - A dictionary provided at the initialization, see keys below.
    - A list of dictionaries provided at initialization
    - A file containing one of: JWKS, DER encoded key
    - A URL pointing to a webpages from which an JWKS can be downloaded
             
    :param keys: A dictionary or a list of dictionaries
        with the keys ["kty", "key", "alg", "use", "kid"]
    :param source: Where the key set can be fetch from
    :param verify_ssl: Verify the SSL cert used by the server
    :param fileformat: For a local file either "jwk" or "der"
    :param keytype: Iff local file and 'der' format what kind of key it is.
        presently only 'rsa' is supported.
    :param keyusage: What the key loaded from file should be used for.
        Only applicable for DER files
    */
    
    this.keys = [];
    this.remote = false;
    this.verify_ssl = verify_ssl;
    this.cache_time = cache_time;
    this.time_out = 0;
    this.etag = "";
    this.source = null;
    this.fileformat = fileformat.toLowerCase();
    this.keytype = keytype;
    this.keyusage = keyusage;
    this.imp_jwks = null;
    this.last_updated = 0;
    this.formattedKeysList = [];

    if (keys){
        this.source = null;
        if (typeof keys ==='object' && keys!==null && !(keys instanceof Array) && !(keys instanceof Date)){
            this.doKeys([keys])
        }else{
            this.doKeys(keys)
        }
    }else{
        if (source.startswith("file://")){
            this.source = source.substring(7);
        }else if (source.startsWith("http://") || source.startsWith("https://")){
            this.source = source
            this.remote = true
        }else if (source == ""){
            return
        }else{
            var formatArr = ['rsa', 'der', 'jwks'];
            if (formatArr.indexOf(fileformat.lower()) != -1){
                if (os.path.isfile(source)){
                    this.source = source
                }else{
                    console.log('No such file')
                }
            }else{
                console.log('Unknown source')
            }
        }
        if (!this.remote){
            var formatArr = ['jwks', "jwk"];
            if (formatArr.indexOf(this.fileformat) != -1){
                this.doLocalJwk(this.source)
            }else if (this.fileformat == "der"){  
                this.doLocalDer(this.source, this.keytype, this.keyusage)
            }
        }
    };
}

var MAP = {'dec': 'enc', 'enc': 'enc', 'ver': 'sig', 'sig': 'sig'};


keyBundle.doKeys = function(keys){    
    for (var key in keys){
        this.keys.push(key);
    }
};

keyBundle.getKty = function(typ=""){
    self.upToDate();
    if (typ != ""){
        var keysList = []
        for (var index in this.imp_jwks.keys){
            var key = this.imp_jwks.keys[index]
            if (key.kty == typ)
                keysList.push(jwkToPem(key));
        }
        return keysList;
    }else{
        return this.keys;
    }
};

keyBundle.getKeyList = function(keys){
    var keysList = []
    var impJwks = this.getJwks();
    if (keys.length == 0 && impJwks){
        keys = impJwks.keys;
    }
    for (var index in keys){
        var key = jwkToPem(keys[index])
        if (keys[index].inactive_since && keys[index].inactive_since <= new Date().getTime() / 1000 ){
            console.log("Key not active :" + keys[index]);
        }else{
            keysList.push(key);
        }
    }
    this.formattedKeysList = keysList;
    return keysList;
};

keyBundle.getKeys = function(){
    if (this.formattedKeysList.length != 0){
        return this.formattedKeysList;
    }
    else if (this.source != ""){
        var HttpClient = function() {
            this.get = function(aUrl, aCallback) {
                var anHttpRequest = new XMLHttpRequest();
                anHttpRequest.onreadystatechange = function() { 
                    if (anHttpRequest.readyState == 4 && anHttpRequest.status == 200)
                        aCallback(anHttpRequest.responseText);
                }
        
                anHttpRequest.open( "GET", aUrl, true );            
                anHttpRequest.send( null );
            }
          }
        
          var client = new HttpClient();
          client.get(this.source, function(response) {
            // do something with response
            var keys = JSON.parse(response).keys;
            return keyBundle.getKeyList(keys);
          });
    }else{
        return this.getKeyList(this.keys);
    }
};

keyBundle.getKeyWithKid = function(kid){
    /*var keys = "";
    if (this.imp_jwks != null)
        keys = this.imp_jwks.keys;
    else{
        keys = this.keys;
    } 
    for (var index in keys){
        var key = keys[index]
        if (key.kid == kid)
            return key;
    }*/

    for (var index in this.keys){
        var key = this.keys[index]
        if (key.kid == kid){
            return key;
        }
    }

    this.update()

    for (var index in this.keys){
        var key = this.keys[index]
        if (key.kid == kid){
            return key;
        }
    }

    return null;
};

keyBundle.getJwks= function(private=false){
    //return this.imp_jwks;   
    self.uptodate();
    var keys = [];
    /*for (k in this.keys){
        if (private){
            //key = k.serialize(private);
        }else{
        }
    }*/
    var jwk = {"keys": keys};
    return JSON.stringify(jwk);
};

keyBundle.remove = function(key){
    var i = this.formattedKeysList.indexOf(key);
    if(i != -1) {
        this.formattedKeysList.splice(i, 1);
    }
    this.source = "";
    this.imp_jwks = "";
};

keyBundle.markAsInactive = function(kid){
   var k =  this.getKeyWithKid(kid);
   k.inactive_since = new Date().getTime() / 1000;  
   //this.remove(jwkToPem(k));
};

keyBundle.update = function(){
    //throw new Error("Unsupported Operation Exception");    
    /*
    Reload the keys if necessary
    This is a forced update, will happen even if cache time has not elapsed
    Replaced keys will be marked as inactive and not removed.        
    */
    res = true  
    if (this.source){
        var keys = this.keys  
        this.keys = []

        try{
            if (this.remote == false){
                if (this.fileformat == "jwks"){
                    this.doLocalJwk(self.source)
                }else if (this.fileformat == "der"){
                    this.doLocalDer(this.source, this.keytype,
                                      this.keyusage)
                }
            }else{
                res = this.doRemote()
            }
        }catch(err){
            console.log('Key bundle update failed: {}' + err)
            this.keys = keys;
            return false
        }

        now = new Date().getTime() / 1000;
        for (var key in this.keys){
            if (this.keys.indexOf(key) == -1){
                try{
                    key.inactive_since;
                }catch(err){
                    key.inactive_since = now
                }
                this.keys.push(key);
            }
        }
    }
    return res;
    
};

keyBundle.removeOutdated = function(after, when=0){
    /*
    Remove keys that should not be available any more.
    Outdated means that the key was marked as inactive at a time
    that was longer ago then what is given in 'after'.
    :param after: The length of time the key will remain in the KeyBundle
        before it should be removed.
    :param when: To make it easier to test
    */

    if (when){
        now = when
    }else{
        now = new Date().getTime() / 1000;
    }
    if (after instanceof float){
        try{
            after = float(after)
        }catch(err){
            console.log(err);
        }
    }
    kl = []
    for (k in this.keys){
        if (k.inactive_since && k.inactive_since + after < now){
            continue
        }else{
            kl.append(k)
        }
    }
    this.keys = kl
};

keyBundle.doLocalJwk = function(filePath){
    //throw new Error("Unsupported Operation Exception"); 
    
    fs.readFile(filePath, {encoding: 'utf-8'}, function(err,data){
        if (!err) {
            console.log('received data: ' + data);
            var keys = JSON.parse(data).keys;
            this.doKeys(keys);
            //this.formattedKeysList = keyBundle.getKeyList(keys);
        } else {
            console.log(err);
        }
        this.last_updated = new Date().getTime() / 1000;
    });
      
};

keyBundle.doLocalDer = function(filename, keytype, keyUsage){
    fs.readFile(filePath, {encoding: 'utf-8'}, function(err,data){
        if (!err) {
            console.log('received data: ' + data);
            var keys = JSON.parse(data).keys;
            var certDerBytes = forge.util.decode64(keys[0].x5c[0]);
            // parse DER to an ASN.1 object
            var obj = forge.asn1.fromDer(certDerBytes);
            // convert ASN.1 object to forge certificate object
            var cert = forge.pki.certificateFromAsn1(obj);
            // get forge public key object
            var publicKey = cert.publicKey;
            // if you did want to convert it to PEM format for transport:
            //var pem = forge.pki.publicKeyToPem(publicKey);
            //this.formattedKeysList = keyBundle.getKeyList(keys);
            this.keys.push(key);
        } else {
            console.log(err);
        }
        this.last_updated = new Date().getTime() / 1000;
    });
};

keyBundle.doRemote = function(){
    //throw new Error("Unsupported Operation Exception");    
    var args = {"verify": self.verify_ssl};
    if (this.etag){
        args["headers"] = {"If-None-Match":self.etag};
    }

    var HttpClient = function() {
        this.get = function(aUrl, aCallback) {
            var anHttpRequest = new XMLHttpRequest();
            anHttpRequest.onreadystatechange = function() { 
                if (anHttpRequest.readyState == 4 && anHttpRequest.status == 200)
                    aCallback(anHttpRequest.response);
            }
    
            anHttpRequest.open( "GET", aUrl, true );    
            anHttpRequest.setRequestHeader("Content-type", "application/json; charset=utf-8");
            anHttpRequest.setRequestHeader("Content-length", args.length);
            anHttpRequest.setRequestHeader("Connection", "close");
            anHttpRequest.send(JSON.stringify(args));
        }
      }
    
      var client = new HttpClient();
      client.get(this.source, function(response) {
        // do something with response

        if (response.status == 304){
            this.time_out = new Date().getTime() / 1000 + this.cache_time;
            this.last_updated = new Date().getTime() / 1000 
            try{
                this.doKeys(this.imp_jwks["keys"]);
            }catch(err){
                console.log("No 'keys' keyword in JWKS");
            } 
        }else if (response.status == 200){
            this.time_out = new Date().getTime() / 1000 + this.cache_time

            this.imp_jwks = this.parseRemoteResponse(response);
            if (!(typeof this.imp_jwks ==='object' && this.imp_jwks !==null && !(this.imp_jwks instanceof Array) && !(this.imp_jwks instanceof Date)) && !(JSON.parse(this.imp_jwks).keys)){
                console.log("Malformed format for Imported JWK");
            }

            try{
                self.doKeys(JSON.parse(this.imp_jwks).keys)                
            }catch(err){
                console.log("No 'keys' keyword in JWKS");
                console.log("MALFORMED FORMAT")
            }
            try{
                self.etag = response.headers["Etag"]                
            }catch(err){
                console.log("Etag err")
            }
        }else{
            console.log("Update Failed");
        }
        });
    self.last_updated = new Date().getTime() / 1000 
    return true

};

keyBundle.upToDate = function(){
    //throw new Error("Unsupported Operation Exception");    
    var res = false
    if (this.keys != []){
        if (this.remote){ 
            if (new Date().getTime() / 1000 > this.time_out){
                if (this.update()){
                    res = true
                }
            }
        }
    }else if (this.remote){
        if (this.update()){
            res = true
        }
    }        
    return res;
}

keyBundle.parseRemoteResponse = function(response){   
    try{
        if (response.headers["Content-Type"] != 'application/json'){
            console.log("Wrong Content Type" + response.headers["Content-Type"])
        }
    }catch(err){
        pass
    }
    
    try{
        return JSON.parse(response);
    }catch(err){
        console.log("Value error");
    }
};

keyBundle.keys = function(){
    self.upToDate();
    return this.keys;   
}

keyBundle.activeKeys = function(){
    //throw new Error("Unsupported Operation Exception");   
    var res = []
    for (var k in self._keys){
        try{
            ias = k.inactive_since
        }catch(err){
            res.append(k)
        }
        if (ias == 0){
            res.append(k)
        }
    }
    return res
}

keyBundle.removeKeysByType = function(type){
    var keys = this.getKty(type);
    for (var k in keys){
        this.remove(k);
    }
};


keyBundle.append = function(key){
    this.keys.push(key); 
};

keyBundle.kids = function(){
    //throw new Error("Unsupported Operation Exception");    
    self.uptodate();
    var kidsArr = [];
    for (var key in this.keys){
        if (key.kid != ""){
            kidsArr.push(key.kid)
        }
    }
    return kidsArr;
};

keyBundle.harmonizeUsage= function(fileName, typ, usage){
    /*
    :param use:
    :return: list of usage
    */
    if (type(use) in six.string_types){
        return [MAP[use]]        
    }else if (use instanceof list){
        ul = list(MAP.keys())
        var list = []
        var set = new Set();
        for (var u in use){
            if (ul.indexOf(u) != -1){
                set.add(MAP[u])
            }
        }
        return Array.from(set)
    }
}

keyBundle.keybundleFromLocalFile= function(fileName, typ, usage){
    //throw new Error("Unsupported Operation Exception");    
    /*
    Create a KeyBundle based on the content in a local file
    
    :param filename: Name of the file 
    :param typ: Type of content
    :param usage: What the key should be used for
    :return: The created KeyBundle
    */
    usage = harmonize_usage(usage)

    if (typ.toLowerCase() == "jwks"){
        kb = KeyBundle([], filename, "jwks", usage)
    }else if (typ.toLowerCase() == 'der'){
        kb = KeyBundle([], filename, "der", usage)
    }else{
        console.log("Unsupported key type")
    }

    return kb
};

keyBundle.dumpJwks= function(kbl, target, private=false){
    throw new Error("Unsupported Operation Exception");    
};    

module.exports = KeyBundle;

